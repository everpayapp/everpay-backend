"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SignatureError = exports.extractJku = exports.extractKid = exports.verify = exports.sign = void 0;
var jws_1 = __importDefault(require("jws"));
var jwk_to_pem_1 = __importDefault(require("jwk-to-pem"));
var js_base64_1 = require("js-base64");
var error_1 = require("./error");
Object.defineProperty(exports, "SignatureError", { enumerable: true, get: function () { return error_1.SignatureError; } });
var headers_1 = require("./headers");
var requireArg = function (arg, name) {
    if (!arg)
        throw new Error("missing argument ".concat(name));
    return arg;
};
var hasMessage = function (e) {
    return typeof e === "object" && e !== null && "message" in e;
};
var buildV2SigningPayload = function (_a) {
    var method = _a.method, path = _a.path, headers = _a.headers, body = _a.body;
    if (!path.startsWith('/')) {
        throw new Error("Invalid path \"".concat(path, "\" must start with '/'"));
    }
    if (!(typeof body === 'string' || body instanceof String)) {
        throw new Error("Invalid body '".concat(typeof body, "' type must be a string"));
    }
    var payload = "".concat(method, " ").concat(path, "\n");
    for (var _i = 0, _b = headers.entries; _i < _b.length; _i++) {
        var _c = _b[_i], key = _c[0], value = _c[1];
        payload += "".concat(key, ": ").concat(value, "\n");
    }
    payload += body;
    return payload;
};
var signPayload = function (_a) {
    var privateKeyPem = _a.privateKeyPem, kid = _a.kid, payload = _a.payload, headerNames = _a.headerNames;
    try {
        var _b = jws_1.default
            .sign({
            header: {
                alg: "ES512",
                kid: kid,
                tl_version: "2",
                tl_headers: headerNames.join(","),
            },
            payload: payload,
            privateKey: privateKeyPem,
        })
            .split("."), header = _b[0], _ = _b[1], signature = _b[2];
        return "".concat(header, "..").concat(signature);
    }
    catch (e) {
        var message = hasMessage(e) ? e.message : "Signature error";
        throw new error_1.SignatureError(message);
    }
};
var parseSignature = function (signature) {
    try {
        var _a = signature.split("."), header = _a[0], _ = _a[1], footer = _a[2];
        var headerJson = parseHeader(header);
        error_1.SignatureError.ensure(headerJson.alg === "ES512", "unsupported header alg");
        error_1.SignatureError.ensure(headerJson.tl_version === "2", "unsupported header tl_version");
        return {
            headerJson: headerJson,
            header: header,
            footer: footer,
        };
    }
    catch (e) {
        var message = hasMessage(e) ? e.message : "Signature error";
        throw new error_1.SignatureError(message);
    }
};
function parseHeader(header) {
    var headerJson = undefined;
    try {
        headerJson = JSON.parse(js_base64_1.Base64.decode(header));
    }
    catch (error) {
        if (error instanceof Error) {
            throw new error_1.SignatureError("Failed to parse JWS: " + error.message);
        }
        else {
            throw new error_1.SignatureError("Failed to parse JWS");
        }
    }
    if (headerJson === undefined) {
        throw new error_1.SignatureError("Failed to parse JWS");
    }
    return headerJson;
}
/** Sign/verification error
 * SignatureError: SignatureError,
 * Produce a JWS `Tl-Signature` v2 header value.
 * @param {Object} args - Arguments.
 * @param {string} args.privateKeyPem - Private key pem.
 * @param {string} args.kid - Private key kid.
 * @param {string} [args.method="POST"] - Request method, e.g. "POST".
 * @param {string} args.path - Request path, e.g. "/payouts".
 * @param {string} [args.body=""] - Request body.
 * @param {Object} [args.headers={}] - Request headers to be signed.
 * Warning: Only a single value per header name is supported.
 * @returns {string} Tl-Signature header value.
 * @throws {SignatureError} Will throw if signing fails.
 */
function sign(args) {
    var kid = requireArg(args.kid, "kid");
    var privateKeyPem = requireArg(args.privateKeyPem, "privateKeyPem");
    var method = (args.method || "POST" /* HttpMethod.Post */).toUpperCase();
    var path = requireArg(args.path, "path");
    var headers = new headers_1.Headers(args.headers || {}).validated();
    var body = args.body || "";
    var payload = buildV2SigningPayload({ method: method, path: path, headers: headers, body: body });
    return signPayload({
        privateKeyPem: privateKeyPem,
        kid: kid,
        payload: payload,
        headerNames: headers.names(),
    });
}
exports.sign = sign;
/**
 * Determine if these parameters contain jwks
 * @param args
 * @returns
 */
function isJwkParameters(args) {
    return 'jwks' in args;
}
function verify(args) {
    var signature = requireArg(args.signature, "signature");
    var _a = parseSignature(signature), headerJson = _a.headerJson, header = _a.header, footer = _a.footer;
    var publicKeyPem;
    if (isJwkParameters(args)) {
        var jwks = JSON.parse(args.jwks);
        var jwk = jwks.keys.find(function (k) { return k.kid === headerJson.kid; });
        error_1.SignatureError.ensure(!!jwk, "no jwk found for signature kid");
        publicKeyPem = (0, jwk_to_pem_1.default)(jwk);
    }
    else {
        publicKeyPem = requireArg(args.publicKeyPem, "publicKeyPem");
    }
    var method = requireArg(args.method, "method").toUpperCase();
    var path = requireArg(args.path, "path");
    var body = args.body || "";
    var requiredHeaders = args.requiredHeaders || [];
    var headers = new headers_1.Headers(args.headers || {}).validated();
    var tlHeaders = (headerJson.tl_headers || "").split(",").filter(function (h) { return !!h; });
    var _loop_1 = function (required) {
        var wasSigned = tlHeaders.some(function (header) { return header.toLowerCase() === required.toLowerCase(); });
        error_1.SignatureError.ensure(wasSigned, "signature is missing required header ".concat(required));
    };
    // fail if signature is missing a required header
    for (var _i = 0, requiredHeaders_1 = requiredHeaders; _i < requiredHeaders_1.length; _i++) {
        var required = requiredHeaders_1[_i];
        _loop_1(required);
    }
    headers.retainAndSort(tlHeaders);
    var payload = buildV2SigningPayload({ method: method, path: path, headers: headers, body: body });
    var fullSignature = "".concat(header, ".").concat(js_base64_1.Base64.encode(payload, true), ".").concat(footer);
    if (!jws_1.default.verify(fullSignature, headerJson.alg, publicKeyPem)) {
        // try again with/without a trailing slash (#80)
        var path2 = path + '/';
        if (path.endsWith('/')) {
            path2 = path.slice(0, path.length - 1);
        }
        var payload_1 = buildV2SigningPayload({ method: method, path: path2, headers: headers, body: body });
        var fullSignature_1 = "".concat(header, ".").concat(js_base64_1.Base64.encode(payload_1, true), ".").concat(footer);
        if (!jws_1.default.verify(fullSignature_1, headerJson.alg, publicKeyPem)) {
            throw new error_1.SignatureError("Invalid signature");
        }
    }
}
exports.verify = verify;
/**
 * Extract kid from unverified jws Tl-Signature.
 * @param {string} tlSignature - Tl-Signature header value.
 * @returns {string} Tl-Signature header kid.
 * @throws {SignatureError} Will throw if signature is invalid.
 */
function extractKid(tlSignature) {
    return parseSignature(tlSignature).headerJson.kid;
}
exports.extractKid = extractKid;
/**
 * Extract jku from unverified jws Tl-Signature.
 * @param {string} tlSignature - Tl-Signature header value.
 * @returns {string?} Tl-Signature header jku.
 * @throws {SignatureError} Will throw if signature is invalid.
 */
function extractJku(tlSignature) {
    return parseSignature(tlSignature).headerJson.jku;
}
exports.extractJku = extractJku;
